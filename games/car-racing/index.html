<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Neon Drift: Crash Update</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: "Courier New", Courier, monospace;
      }

      /* UI OVERLAYS */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }
      .hud-top {
        display: flex;
        justify-content: space-between;
        padding: 20px;
        color: #fff;
        font-weight: bold;
        font-size: 24px;
        text-shadow: 2px 2px #ff0055;
      }
      .speedometer {
        position: absolute;
        bottom: 20px;
        right: 20px;
        color: #00ffff;
        font-size: 48px;
        font-style: italic;
        text-shadow: 3px 3px #000;
      }

      /* CRASH FLASH */
      #crash-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: red;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.1s;
      }

      /* START SCREEN */
      #start-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
        cursor: pointer;
        color: white;
      }
      h1 {
        font-size: 60px;
        color: #ff0055;
        margin: 0;
        text-transform: uppercase;
        font-style: italic;
      }
      .blink {
        animation: blinker 1s linear infinite;
        margin-top: 20px;
        font-size: 24px;
      }
      @keyframes blinker {
        50% {
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <div id="game-container"></div>
    <div id="crash-overlay"></div>

    <div id="ui-layer">
      <div class="hud-top">
        <div id="time">TIME: 60</div>
        <div id="score">SCORE: 0</div>
      </div>
      <div class="speedometer"><span id="speed">0</span> km/h</div>
    </div>

    <div id="start-screen">
      <h1>NEON DRIFT</h1>
      <div class="blink">[ CLICK TO START ]</div>
      <p style="margin-top: 30px; color: #aaa">
        Avoid the Grass! | SPACE to Drift
      </p>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      // --- CONFIG ---
      const CFG = {
        roadWidth: 20, // Total width (center to edge is 10)
        segLength: 10,
        numSegments: 60,
        maxSpeed: 1.2,
        accel: 0.01,
        decel: 0.02,
        turnSpeed: 0.05,
        colors: {
          road: 0x222222,
          grass: 0x101010,
          curbR: 0xff0055,
          curbW: 0xffffff,
        },
      };

      // --- GAME STATE ---
      let state = {
        playing: false,
        speed: 0,
        distance: 0,
        playerX: 0,
        timeLeft: 60,
        score: 0,
        isCrashed: false,
        crashTimer: 0,
      };

      const keys = {
        ArrowUp: false,
        ArrowDown: false,
        ArrowLeft: false,
        ArrowRight: false,
        Space: false,
      };

      // --- SCENE SETUP ---
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0f0c29);
      scene.fog = new THREE.FogExp2(0x0f0c29, 0.015);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 3, 8);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document
        .getElementById("game-container")
        .appendChild(renderer.domElement);

      const ambient = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambient);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
      dirLight.position.set(5, 10, 0);
      scene.add(dirLight);

      // --- OBJECTS ---

      // CAR GROUP
      const carGroup = new THREE.Group();
      const bodyMesh = new THREE.Mesh(
        new THREE.BoxGeometry(1.6, 0.6, 3.5),
        new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.3 })
      );
      bodyMesh.position.y = 0.5;
      carGroup.add(bodyMesh);
      const cabinMesh = new THREE.Mesh(
        new THREE.BoxGeometry(1.4, 0.5, 1.8),
        new THREE.MeshStandardMaterial({ color: 0x222222 })
      );
      cabinMesh.position.set(0, 1.0, -0.2);
      carGroup.add(cabinMesh);
      const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.4, 12);
      const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
      [
        [-0.9, 1.2],
        [0.9, 1.2],
        [-0.9, -1.2],
        [0.9, -1.2],
      ].forEach((pos) => {
        const w = new THREE.Mesh(wheelGeo, wheelMat);
        w.rotation.z = Math.PI / 2;
        w.position.set(pos[0], 0.35, pos[1]);
        carGroup.add(w);
      });
      scene.add(carGroup);

      // ROAD SEGMENTS
      const segments = [];
      function createSegment(index) {
        const group = new THREE.Group();

        // Road
        const road = new THREE.Mesh(
          new THREE.PlaneGeometry(CFG.roadWidth, CFG.segLength),
          new THREE.MeshPhongMaterial({ color: CFG.colors.road })
        );
        road.rotation.x = -Math.PI / 2;
        group.add(road);

        // Curbs
        const curbGeo = new THREE.PlaneGeometry(1.5, CFG.segLength);
        const curbMat = new THREE.MeshBasicMaterial({
          color: index % 2 === 0 ? CFG.colors.curbR : CFG.colors.curbW,
        });
        const leftCurb = new THREE.Mesh(curbGeo, curbMat);
        leftCurb.rotation.x = -Math.PI / 2;
        leftCurb.position.x = -CFG.roadWidth / 2 - 0.75;
        const rightCurb = new THREE.Mesh(curbGeo, curbMat);
        rightCurb.rotation.x = -Math.PI / 2;
        rightCurb.position.x = CFG.roadWidth / 2 + 0.75;
        group.add(leftCurb);
        group.add(rightCurb);

        // Grass
        const grass = new THREE.Mesh(
          new THREE.PlaneGeometry(200, CFG.segLength),
          new THREE.MeshBasicMaterial({
            color: (index / 2) % 2 === 0 ? 0x151515 : 0x101010,
          })
        );
        grass.rotation.x = -Math.PI / 2;
        grass.position.y = -0.05;
        group.add(grass);
        return group;
      }

      for (let i = 0; i < CFG.numSegments; i++) {
        const seg = createSegment(i);
        seg.position.z = -i * CFG.segLength;
        scene.add(seg);
        segments.push(seg);
      }

      // PARTICLES
      const particlesGeo = new THREE.BufferGeometry();
      const pPos = new Float32Array(600);
      for (let i = 0; i < 600; i++) pPos[i] = (Math.random() - 0.5) * 100;
      particlesGeo.setAttribute("position", new THREE.BufferAttribute(pPos, 3));
      const particles = new THREE.Points(
        particlesGeo,
        new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 })
      );
      scene.add(particles);

      // --- INPUT ---
      window.addEventListener("keydown", (e) => (keys[e.code] = true));
      window.addEventListener("keyup", (e) => (keys[e.code] = false));

      // --- AUDIO ENGINE ---
      let audioCtx, osc, noiseNode, gainNode, crashGain;

      function initAudio() {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Engine Sound
        osc = audioCtx.createOscillator();
        gainNode = audioCtx.createGain();
        osc.type = "sawtooth";
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        osc.start();
        gainNode.gain.value = 0.0; // Start silent

        // Update pitch
        setInterval(() => {
          if (state.playing && !state.isCrashed) {
            osc.frequency.setTargetAtTime(
              50 + state.speed * 400,
              audioCtx.currentTime,
              0.1
            );
            gainNode.gain.setTargetAtTime(
              0.05 + state.speed * 0.1,
              audioCtx.currentTime,
              0.1
            );
          } else {
            gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
          }
        }, 100);
      }

      function playCrashSound() {
        if (!audioCtx) return;
        // Create White Noise Buffer
        const bufferSize = audioCtx.sampleRate * 0.5; // 0.5 seconds
        const buffer = audioCtx.createBuffer(
          1,
          bufferSize,
          audioCtx.sampleRate
        );
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }

        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const noiseGain = audioCtx.createGain();
        noiseGain.gain.value = 0.5;

        noise.connect(noiseGain);
        noiseGain.connect(audioCtx.destination);
        noise.start();
      }

      // --- PHYSICS & LOGIC ---

      function triggerCrash() {
        state.isCrashed = true;
        state.crashTimer = 60; // Frames to spin
        state.speed = 0;

        playCrashSound();

        // Visual Flash
        const overlay = document.getElementById("crash-overlay");
        overlay.style.opacity = 0.5;
        setTimeout(() => (overlay.style.opacity = 0), 200);

        // Bounce back towards center slightly
        const bounceDir = state.playerX > 0 ? -1 : 1;
        state.playerX += bounceDir * 2;
      }

      function updatePhysics() {
        // HANDLE CRASH STATE
        if (state.isCrashed) {
          state.crashTimer--;

          // Spin animation
          carGroup.rotation.y += 0.4;
          carGroup.rotation.z = (Math.random() - 0.5) * 0.2; // Shake

          if (state.crashTimer <= 0) {
            state.isCrashed = false;
            carGroup.rotation.y = 0;
            carGroup.rotation.z = 0;
          }
          return; // SKIP normal movement
        }

        // NORMAL DRIVING
        if (keys.ArrowUp) state.speed += CFG.accel;
        else state.speed -= CFG.decel / 2;
        if (keys.ArrowDown) state.speed -= CFG.decel;

        state.speed = Math.max(0, Math.min(state.speed, CFG.maxSpeed));
        state.distance += state.speed;

        // STEERING
        let turn = 0;
        if (keys.ArrowLeft) turn = 1;
        if (keys.ArrowRight) turn = -1;

        const isDrifting = keys.Space && state.speed > 0.3;
        const turnPower = isDrifting ? CFG.turnSpeed * 0.6 : CFG.turnSpeed;

        // Move Player
        state.playerX += turn * turnPower * (state.speed * 2.5);

        // --- CRASH CHECK ---
        // Road width is CFG.roadWidth (20). Half is 10.
        // Give a little buffer (11) so wheels can touch grass slightly.
        if (Math.abs(state.playerX) > CFG.roadWidth / 2 + 1.5) {
          if (state.speed > 0.2) {
            triggerCrash();
          } else {
            // Just clamp if moving super slow
            state.playerX =
              Math.sign(state.playerX) * (CFG.roadWidth / 2 + 1.5);
          }
        }

        // CAR VISUALS
        const targetRot = turn * (isDrifting ? 0.6 : 0.3);
        carGroup.rotation.y += (targetRot - carGroup.rotation.y) * 0.1;
        carGroup.rotation.z = -turn * 0.1; // Roll
        carGroup.position.x = state.playerX;

        // UI
        state.score += state.speed;
        document.getElementById("speed").innerText = Math.floor(
          state.speed * 200
        );
        document.getElementById("score").innerText =
          "SCORE: " + Math.floor(state.score);
      }

      function renderWorld() {
        const totalTrackLength = CFG.numSegments * CFG.segLength;
        const curveAmount = Math.sin(state.distance * 0.01) * 40; // World Curve

        for (let i = 0; i < segments.length; i++) {
          const seg = segments[i];
          let zPos =
            (-i * CFG.segLength + state.distance * 10) % totalTrackLength;
          if (zPos > 10) zPos -= totalTrackLength;

          seg.position.z = zPos;
          const depth = Math.abs(zPos) / 100;
          seg.position.x = depth * depth * curveAmount; // Curve effect
          seg.visible = zPos < 5;
        }

        // Move Particles
        const positions = particles.geometry.attributes.position.array;
        for (let i = 2; i < positions.length; i += 3) {
          positions[i] += state.speed * 20;
          if (positions[i] > 10) positions[i] = -100;
        }
        particles.geometry.attributes.position.needsUpdate = true;
      }

      function animate() {
        if (!state.playing) return;
        updatePhysics();
        renderWorld();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      // --- INIT ---
      const startBtn = document.getElementById("start-screen");
      startBtn.addEventListener("click", () => {
        startBtn.style.display = "none";
        initAudio();
        state.playing = true;
        setInterval(() => {
          if (state.playing && state.timeLeft > 0) {
            state.timeLeft--;
            document.getElementById("time").innerText =
              "TIME: " + state.timeLeft;
            if (state.timeLeft === 0) {
              state.playing = false;
              alert("GAME OVER - Score: " + Math.floor(state.score));
              location.reload();
            }
          }
        }, 1000);
        animate();
      });

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
